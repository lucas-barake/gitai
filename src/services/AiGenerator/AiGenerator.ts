import { AiLanguageModel } from "@/services/AiLanguageModel/AiLanguageModel.js";
import { CliOption } from "@/services/CliOptions.js";
import type { GitCommit } from "@/services/GitClient.js";
import { LocalConfig } from "@/services/LocalConfig.js";
import { Effect } from "effect";
import {
  makeChangelogPrompt,
  makeCommitMessagePrompt,
  makePrDetailsPrompt,
  makeReviewPrompt,
  makeTitlePrompt,
} from "./prompts.js";
import {
  ChangelogResponse,
  CommitMessage,
  PrDetails,
  PrReviewDetails,
  PrTitle,
} from "./schemas.js";

const orDie =
  (message: string) =>
  <A, E extends { message: string }, R>(self: Effect.Effect<A, E, R>) =>
    self.pipe(Effect.orDieWith((error) => `${message}: ${error.message}`));

export const makeReviewCommentTag = (username: string) =>
  `<!-- [gitai-review:${username}](https://github.com/lucas-barake/gitai) -->`;

export class AiGenerator extends Effect.Service<AiGenerator>()("@gitai/AiGenerator", {
  dependencies: [AiLanguageModel.Default, LocalConfig.Default],
  effect: Effect.gen(function* () {
    const ai = yield* AiLanguageModel;
    const localConfig = yield* LocalConfig;

    const formatPrDescription = (details: PrDetails) => {
      const fileSummaries = details.fileSummaries
        .map((summary) => `| ${summary.file} | ${summary.description} |`)
        .join("\n");

      return `${details.description}

<details>
<summary>Show a summary per file</summary>

| File | Description |
| ---- | ----------- |
${fileSummaries}
</details>`;
    };

    const formatReviewAsMarkdown = (review: PrReviewDetails) => {
      const reviewTag = makeReviewCommentTag(localConfig.username);
      const reviewItems = review.review
        .map(
          (item) =>
            `**${item.file}:${item.line}**\n* [${item.category}] ${item.comment}\n\`\`\`\n${item.codeSnippet}\n\`\`\``,
        )
        .join("\n\n");

      return `${reviewTag}\n<details>\n<summary>Review</summary>\n\n${reviewItems}\n</details>`;
    };

    /**
     * Removes autogenerated files from diff to focus AI analysis on code changes
     */
    const filterDiff = Effect.fn("filterDiff")((rawDiff: string) =>
      Effect.sync(() =>
        rawDiff
          .split("diff --git")
          .filter((part) => {
            if (!part.trim()) {
              return false;
            }
            const firstLine = part.substring(0, part.indexOf("\n"));

            const autogeneratedPatterns = [
              /pnpm-lock\.yaml/,
              /yarn\.lock/,
              /package-lock\.json/,
              /bun\.lockb?/,
              /\.lock$/,
              /lockfile/i,
              /coverage\/.*\.json/,
              /\.nyc_output\//,
              /node_modules\//,
              /\.next\//,
              /\.nuxt\//,
              /dist\//,
              /build\//,
              /\.git\//,
              /\.DS_Store/,
            ];

            if (autogeneratedPatterns.some((pattern) => pattern.test(firstLine))) {
              return false;
            }

            return true;
          })
          .map((part) => `diff --git${part}`)
          .join(""),
      ),
    );

    const generatePrDetails = Effect.fn("AiGenerator.generatePrDetails")(function* (diff: string) {
      const model = yield* CliOption("model");
      const context = yield* CliOption("context");
      const filteredDiff = yield* filterDiff(diff);

      return yield* ai
        .generateObject({
          model,
          prompt: makePrDetailsPrompt(filteredDiff, context),
          schema: PrDetails,
          label: "PR details",
        })
        .pipe(
          Effect.map((details) => ({
            title: details.title,
            body: formatPrDescription(details),
          })),
          orDie("Failed to generate PR details"),
        );
    });

    const generateCommitMessage = Effect.fn("AiGenerator.generateCommitMessage")(function* (
      diff: string,
    ) {
      const model = yield* CliOption("model");
      const context = yield* CliOption("context");
      const filteredDiff = yield* filterDiff(diff);

      return yield* ai
        .generateObject({
          model,
          prompt: makeCommitMessagePrompt(filteredDiff, context),
          schema: CommitMessage,
          label: "commit message",
        })
        .pipe(
          Effect.map((generated) => generated.message),
          orDie("Failed to generate commit message"),
        );
    });

    const generateTitle = Effect.fn("AiGenerator.generateTitle")(function* (diff: string) {
      const model = yield* CliOption("model");
      const context = yield* CliOption("context");
      const filteredDiff = yield* filterDiff(diff);

      return yield* ai
        .generateObject({
          model,
          prompt: makeTitlePrompt(filteredDiff, context),
          schema: PrTitle,
          label: "PR title",
        })
        .pipe(
          Effect.map((generated) => generated.title),
          orDie("Failed to generate PR title"),
        );
    });

    const generateReview = Effect.fn("AiGenerator.generateReview")(function* (diff: string) {
      const model = yield* CliOption("model");
      const context = yield* CliOption("context");
      const filteredDiff = yield* filterDiff(diff);

      return yield* ai
        .generateObject({
          model,
          prompt: makeReviewPrompt(filteredDiff, context),
          schema: PrReviewDetails,
          label: "PR review",
        })
        .pipe(Effect.map(formatReviewAsMarkdown), orDie("Failed to generate review"));
    });

    const generateChangelog = Effect.fn("AiGenerator.generateChangelog")(function* (
      commits: ReadonlyArray<GitCommit>,
    ) {
      const model = yield* CliOption("model");
      const context = yield* CliOption("context");

      return yield* ai
        .generateObject({
          model,
          prompt: makeChangelogPrompt(commits, context),
          schema: ChangelogResponse,
          label: "changelog",
        })
        .pipe(orDie("Failed to generate changelog"));
    });

    return {
      generatePrDetails,
      generateCommitMessage,
      generateTitle,
      generateReview,
      generateChangelog,
    } as const;
  }),
}) {}
